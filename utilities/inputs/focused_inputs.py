"""Low-level module that handles the sending of inputs to the focused window through SendInput(...)."""
import asyncio
import ctypes
import random

from ctypes import wintypes
from typing import Literal
from win32com.client import Dispatch
from win32gui import SetForegroundWindow, GetForegroundWindow

from core import SharedResources
from utilities.inputs import _InputsHelpers

KEYEVENTF_EXTENDEDKEY = 0x0001
KEYEVENTF_KEYUP = 0x0002
KEYEVENTF_UNICODE = 0x0004
KEYEVENTF_SCANCODE = 0x0008

ULONG_PTR = ctypes.POINTER(ctypes.c_ulong)


class MouseInputStruct(ctypes.Structure):
    """Contains information about a simulated mouse event."""
    _fields_ = [
        ('dx', wintypes.LONG),  # Absolute x position of the mouse, or relative pixel delta to the previous position if MOUSEEVENTF_MOVE is specified in dwFlags.
        ('dy', wintypes.LONG),  # Absolute y position of the mouse, or relative to the previous position if MOUSEEVENTF_MOVE is specified in dwFlags.
        ('mouseData', wintypes.DWORD),
        ('dwFlags', wintypes.DWORD),
        ('time', wintypes.DWORD),
        ('dwExtraInfo', ULONG_PTR)
    ]


class KeyBdInputStruct(ctypes.Structure):
    """Contains information about a simulated keyboard event."""
    _fields_ = [
        ('wVk', wintypes.WORD),
        ('wScan', wintypes.WORD),
        ('dwFlags', wintypes.DWORD),
        ('time', wintypes.DWORD),
        ('dwExtraInfo', ULONG_PTR)
    ]


class HardwareInputStruct(ctypes.Structure):
    """Contains information about a simulated message generated by an input device other than a keyboard or mouse. Not Implemented."""
    _fields_ = [
        ('uMsg', wintypes.DWORD),
        ('wParamL', wintypes.WORD),
        ('wParamH', wintypes.WORD)
    ]


class CombinedInput(ctypes.Union):
    """Contains information about a simulated event of any kind."""
    _fields_ = [
        ("ki", KeyBdInputStruct),
        ("mi", MouseInputStruct),
        ("hi", HardwareInputStruct)
    ]


class Input(ctypes.Structure):
    """Used by SendInput to store information for synthesizing input events such as keystrokes, mouse movement, and mouse clicks."""
    _fields_ = [
        ("type", wintypes.DWORD),
        ("structure", CombinedInput)
    ]


InputArray = Input * 1
LPINPUT = ctypes.POINTER(InputArray)


class _FocusedInputs(_InputsHelpers):
    """Low-level class that handles the sending of inputs to any window through SendInput(...). Inputs may be bundled together and sent at once."""
    MOUSE = 0
    KEYBOARD = 1
    HARDWARE = 2

    def activate(self) -> None:
        """
        Activates the window associated with this controller. Any key press or mouse click will be sent to the active window.
        :return: None
        """
        if GetForegroundWindow() != self.handle:
            shell = Dispatch("WScript.Shell")
            shell.SendKeys('%')
            SetForegroundWindow(self.handle)

    @SharedResources.requires_focus
    async def _send_inputs(self,
                           inputs: list[list[tuple, float]],
                           cooldown: float = 0.1) -> None:
        """Activates the window associated with this controller and sends the required inputs. This requires window focus.
        An input structure may contain several inputs to be sent simultaneously (without any delay in between).
        If this is not desired, the enforce_delay parameter can be set to True (in higher-level API), and a delay will be enforced between each input.
        :param inputs: list of list[tuple, float]. Each tuple contains the parameters to be sent to SendInput, and the float is delay to be enforced after the input is sent.
            Note: When delays are not enforced, usually the list will be a single tuple, float, and float will be 0.0.
        :param cooldown: Cooldown after all inputs have been sent. Default is 0.1 seconds.
        :return: None
        """
        self.activate()
        for item in inputs:
            input_structure, delay = item
            while self._exported_functions['SendInput'](*input_structure) != input_structure[0].value:
                print('SendInput has failed')
                await asyncio.sleep(0.01)  # This will only be called if the input is not sent successfully.
            await asyncio.sleep(delay)  # Allows for smaller delays between consecutive keys, such as when writing a message in-game, or between KEYUP/KEYDOWN commands.
        await asyncio.sleep(cooldown)

    def _input_array_constructor(self,
                                 keys: list[str],
                                 events: list[str],
                                 enforce_delay: bool,
                                 as_unicode: bool = False,
                                 delay: float = 0.033) -> list[list[tuple, float]]:
        """
        Constructs the input array of structures to be sent to the window associated the provided handle. Send that input through SendInput.
        When enforce_delay is True, an array of length 1 is created for each key/event pair, and a random delay is enforced between each key press.
        Otherwise, an array of length n is created (n == len(keys) == len(events)), and there is no delay as all inputs are sent simultaneously.
        :param keys: list of string representation of the key(s) to be pressed.
        :param events: list of string Literals representing the type of event to be sent. Currently supported: 'keydown', 'keyup'.
        :param enforce_delay: bool. Whether to enforce a delay between each key press or not.
        :param as_unicode: bool. Whether to send the key as a unicode character or not. This is only used when sending a single key and allows to differentiate between lowercase uppercase.
        :param delay: The delay (which will be randomized slightly) between each key press when enforce_delay is True.
        :return: list of list[tuple, float]. Each tuple contains the parameters to be sent to SendInput, and the float is delay to be enforced after the input is sent.
        """

        assert isinstance(keys, list) and isinstance(events, list), f"Keys and messages must be lists."
        assert len(keys) == len(events), f"Msg and keys must have the same length when they are provided as lists."

        nbr_inputs = 1 if enforce_delay else len(keys)
        input_array_class = Input * nbr_inputs
        input_pointer = ctypes.POINTER(input_array_class)
        # TODO - Validate. The original argtypes (defined in __init__) uses a pointer to the Input structure, but I think we need a pointer to the Input *array* structure.
        #  The array length varies between each call, so we need to re-define every time?
        self._exported_functions["SendInput"].argtypes = [wintypes.UINT, input_pointer, wintypes.INT]

        input_list = []
        for idx, item in enumerate(zip(keys, events)):
            key, event = item
            input_list.append(self._input_structure_constructor(key, event, as_unicode))

        if enforce_delay:
            return_val = list()
            for item in input_list:
                input_single_array = input_array_class(item)
                full_params = tuple([wintypes.UINT(1), input_pointer(input_single_array), wintypes.INT(ctypes.sizeof(input_single_array[0]))])
                return_val.append([full_params, random.uniform(delay * 0.95, delay * 1.05)])
            return return_val
        else:
            input_array = input_array_class(*input_list)
            full_input = [tuple([wintypes.UINT(nbr_inputs), input_pointer(input_array), wintypes.INT(ctypes.sizeof(input_array[0]))]), 0.0]
            return [full_input]

    def _input_structure_constructor(self,
                                     key: str,
                                     event: Literal['keyup', 'keydown'],
                                     as_unicode: bool = False) -> Input:
        """
        Constructs the input structure to be sent to the window associated the provided handle. Send that input through SendInput.
        :param key: String representation of the key to be pressed.
        :param event: Whether the event is a keyup or keydown.
        :param as_unicode: bool. Whether to send the key as a unicode character or not. This is only used when sending a single key and allows to differentiate between lowercase uppercase.
        :return: Input structure.
        """
        assert event in ["keyup", "keydown"], f"Event type {event} is not supported"
        flags = KEYEVENTF_EXTENDEDKEY if key in self.EXTENDED_KEYS else 0
        vk_key = self._get_virtual_key(key, False, self._keyboard_layout_handle(self.handle))
        if as_unicode:
            assert len(key) == 1, f"Key {key} must be a single character when as_unicode=True"
            scan_code = self._get_virtual_key(key, True, self._keyboard_layout_handle(self.handle))
            vk_key = 0
            flags |= KEYEVENTF_UNICODE
        else:
            scan_code = self._exported_functions['MapVirtualKeyExW'](vk_key, self.MAPVK_VK_TO_VSC_EX, self._keyboard_layout_handle(self.handle))
        flags = flags | KEYEVENTF_KEYUP if event == 'keyup' else flags

        # keybd_input = KeyBdInputStruct(wintypes.WORD(vk_key), wintypes.WORD(scan_code), wintypes.DWORD(flags), wintypes.DWORD(0), None)
        keybd_input = KeyBdInputStruct(wintypes.WORD(vk_key), wintypes.WORD(scan_code), wintypes.DWORD(flags), wintypes.DWORD(0), None)
        input_struct = Input(type=self.KEYBOARD, structure=CombinedInput(ki=keybd_input))
        return input_struct

    def _setup_exported_functions(self) -> dict[str, callable]:
        """
        :return: Dictionary of exported functions from the ctypes.windll module Expands method from InputHelpers to add SendInput.
        """
        send_input = ctypes.windll.user32.SendInput
        send_input.restype = wintypes.UINT
        send_input.argtypes = [wintypes.UINT, LPINPUT, wintypes.INT]  # LPINPUT is a pointer towards an Input structure, but we don't know the array size in advance
        return {
            **super()._setup_exported_functions(),
            "SendInput": send_input
        }
